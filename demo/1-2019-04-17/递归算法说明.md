# 递归算法实现：生成长度为 5 且元素为 2-32 间不重复的随机数数组

## 算法概述

本项目使用递归算法实现了生成长度为 5 且元素在 2-32 范围内不重复的随机数数组。提供了三种不同的递归实现方式，每种都有其特点和优势。

## 核心递归思想

递归算法的核心思想是：

1. **递归终止条件**：当数组长度达到目标长度（5）时，返回结果
2. **递归步骤**：生成随机数，检查是否重复，如果不重复则添加到数组中
3. **递归调用**：继续调用自身，直到满足终止条件

## 三种实现方式

### 方法 1：基础递归实现

```javascript
function generateUniqueRandomArray(
  result = [],
  targetLength = 5,
  min = 2,
  max = 32
) {
  // 递归终止条件：数组长度达到目标长度
  if (result.length === targetLength) {
    return result;
  }

  // 生成随机数
  const randomNum = getRandomInt(min, max);

  // 检查是否重复
  if (!result.includes(randomNum)) {
    // 如果不重复，添加到结果数组中
    result.push(randomNum);
  }

  // 递归调用，继续生成下一个数
  return generateUniqueRandomArray(result, targetLength, min, max);
}
```

**特点：**

- 简单直观，易于理解
- 使用数组的 `includes()` 方法检查重复
- 时间复杂度：O(n²)，因为每次检查重复都需要遍历数组

### 方法 2：使用 Set 优化的递归实现

```javascript
function generateUniqueRandomArrayWithSet(
  usedNumbers = new Set(),
  result = [],
  targetLength = 5,
  min = 2,
  max = 32
) {
  // 递归终止条件
  if (result.length === targetLength) {
    return result;
  }

  // 生成随机数
  const randomNum = getRandomInt(min, max);

  // 使用Set检查重复，效率更高
  if (!usedNumbers.has(randomNum)) {
    usedNumbers.add(randomNum);
    result.push(randomNum);
  }

  // 递归调用
  return generateUniqueRandomArrayWithSet(
    usedNumbers,
    result,
    targetLength,
    min,
    max
  );
}
```

**特点：**

- 使用 Set 数据结构优化重复检查
- 时间复杂度：O(n)，Set 的查找和插入都是 O(1)
- 空间复杂度稍高，需要额外的 Set 存储

### 方法 3：预先创建数字池的优化递归实现

```javascript
function generateUniqueRandomArrayOptimized(
  availableNumbers = null,
  result = [],
  targetLength = 5
) {
  // 初始化可选数字池
  if (availableNumbers === null) {
    availableNumbers = [];
    for (let i = 2; i <= 32; i++) {
      availableNumbers.push(i);
    }
  }

  // 递归终止条件
  if (result.length === targetLength) {
    return result;
  }

  // 从可选数字池中随机选择一个索引
  const randomIndex = getRandomInt(0, availableNumbers.length - 1);

  // 取出该数字并从池中移除
  const selectedNumber = availableNumbers.splice(randomIndex, 1)[0];
  result.push(selectedNumber);

  // 递归调用
  return generateUniqueRandomArrayOptimized(
    availableNumbers,
    result,
    targetLength
  );
}
```

**特点：**

- 预先创建包含所有可能数字的池
- 每次随机选择后直接移除，天然避免重复
- 时间复杂度：O(n)
- 最高效的实现方式

## 算法分析

### 时间复杂度比较

1. **方法 1**：O(n²) - 每次都需要遍历数组检查重复
2. **方法 2**：O(n) - Set 的查找是 O(1)
3. **方法 3**：O(n) - 直接从池中选择，无需重复检查

### 空间复杂度比较

1. **方法 1**：O(n) - 只需要结果数组
2. **方法 2**：O(n) - 需要额外的 Set 存储
3. **方法 3**：O(n) - 需要数字池数组

### 递归深度

- 最好情况：5 次递归（每次都生成不重复的数）
- 最坏情况：理论上可能无限递归（一直生成重复数）
- 实际情况：由于范围是 2-32（31 个数），选择 5 个数的概率很高

## 测试结果

运行 Python 版本的测试结果：

```
=== 递归生成不重复随机数数组测试 ===

方法1：基础递归实现
测试1: [14, 4, 15, 9, 28] - 长度: 5
测试2: [18, 10, 11, 26, 25] - 长度: 5
测试3: [6, 19, 24, 20, 23] - 长度: 5

方法2：使用Set优化的递归实现
测试1: [18, 3, 10, 4, 14] - 长度: 5
测试2: [11, 5, 25, 20, 8] - 长度: 5
测试3: [2, 8, 3, 26, 13] - 长度: 5

方法3：预先创建数字池的优化递归实现
测试1: [18, 19, 25, 17, 32] - 长度: 5
测试2: [24, 13, 8, 20, 15] - 长度: 5
测试3: [21, 16, 6, 28, 22] - 长度: 5

=== 验证测试 ===
生成的数组: [30, 31, 6, 18, 22]
数组长度: 5
所有元素都在2-32范围内: True
所有元素都不重复: True
```

## 使用方法

### JavaScript 版本

```bash
node simple-recursive-array.js
```

### Python 版本

```bash
python3 recursive_random_array.py
```

## 总结

三种递归实现都能成功生成符合要求的随机数数组：

- **长度为 5**
- **元素范围在 2-32 之间**
- **所有元素不重复**

推荐使用**方法 3**（预先创建数字池），因为它效率最高且逻辑最清晰。对于学习递归概念，**方法 1**最容易理解。
